# Memory and Emotion Architecture Guide

이 문서는 현재 프로젝트의 메모리/감정 시스템을 정리한 것이다.

대상 범위:
- `sqlite + sqlite-vec` 기반 메모리 저장/검색 설계
- 단기 기억(short-term)과 장기 기억(long-term) 분리 전략
- 감정 판정(JSON one-hot)과 UI 반영 구조

기준 코드:
- `system/memory_chain.py`
- `system/webapi/services.py`
- `system/llm_engine.py`
- `main_loop.py`
- `system/webapi/demo.py`

---

## 1. 왜 메모리를 2계층으로 나누는가

대화형 시스템에서 메모리를 하나의 방식으로만 처리하면 곧 한계가 온다.

- 최근 문맥은 빠르게 반영돼야 한다.
- 오래된 정보는 요약/정제되어야 한다.
- 모든 기록을 매번 LLM에 넣으면 느리고 비싸다.

그래서 이 프로젝트는 메모리를 다음처럼 분리한다.

1. **단기 기억(Short-term)**
- 최근 대화 몇 턴을 메모리에 직접 들고 있는 방식
- 즉시성은 좋지만 저장 범위가 짧다

2. **장기 기억(Long-term)**
- SQLite에 기록하고, 장기 가치가 있는 정보만 슬롯으로 유지
- 검색해서 필요한 시점에만 프롬프트에 주입한다

핵심 철학은 "모든 것을 기억"하는 것이 아니라, **필요한 것을 구조화해 재사용**하는 것이다.
사람도 까먹으니까 캐릭터도 어느 정도는 까먹도록 허용해야 하지 않을까?

---

## 2. 저장소를 sqlite + sqlite-vec으로 둔 이유

### 2.1 SQLite를 쓰는 이유

SQLite는 이 구조에서 다음 장점이 있다.

- 파일 기반이라 배포/백업이 단순하다
- 스키마가 명확해 추적/디버깅이 쉽다
- 트랜잭션/인덱스 기반으로 일관성을 확보하기 쉽다

즉, "대화 기록 데이터베이스"로써 운영 난이도가 낮고 충분히 강력하다.

### 2.2 sqlite-vec을 붙이는 이유

장기 기억 retrieval에서 단순 문자열 매칭만 쓰면 한계가 있다.
- 표현이 조금만 달라도 놓칠 수 있다.

sqlite-vec을 쓰면,
- 슬롯을 벡터로 저장해 의미 유사도 기반 검색이 가능해진다.
- 별도 벡터 서버를 띄우지 않고 SQLite 내부에서 해결할 수 있다.

즉, **운영 단순성(SQLite)**과 **의미 검색(vector)**을 함께 가져가려는 선택이다.

---

## 3. 데이터 모델링을 어떻게 했는가

메모리 시스템은 테이블을 "역할"로 나누는 것이 핵심이다.

### 3.1 `chat_turns`: 사실 로그

역할:
- user/assistant 원문 턴 저장

의미:
- 이 테이블은 진실 원장(ground truth)이다.
- 나중에 요약이 잘못돼도 원본 근거를 복구할 수 있다.

### 3.2 `memory_candidates`: 판단 로그

역할:
- LLM이 추출한 "장기기억 후보"를 점수와 함께 저장

의미:
- 왜 어떤 정보가 중요하다고 판단됐는지 감사(audit) 가능
- 후보 단계와 승격 단계를 분리해 품질 튜닝 가능

### 3.3 `memory_slots`: 실제 장기기억

역할:
- 승격된 항목만 유지하는 실사용 테이블

의미:
- retrieval 대상은 슬롯만 본다.
- 후보와 슬롯을 분리했기 때문에 검색 잡음이 줄어든다.

### 3.4 `memory_slot_vec`: 슬롯의 임베딩 인덱스

역할:
- 슬롯을 벡터로 저장해 의미 검색 수행

의미:
- 슬롯 ID와 vec rowid를 1:1로 맞춰 관리 복잡도를 줄인다.

---

## 4. 장기기억 승격 로직을 왜 점수화했는가

장기기억은 "LLM이 뽑았다고 바로 저장"하면 쉽게 오염된다.
그래서 후보를 점수화해 승격 조건을 둔다.

점수 구성 의도:

- `type importance`:
  - 약속/경계/사실은 장기 영향이 커서 가중치 높임

- `confidence`:
  - 추출 내용 자체의 신뢰도

- `future_impact`:
  - 다음 대화/관계에 영향을 줄 가능성

- `emotion_intensity`:
  - 감정 강도 높은 항목은 장기 관계에서 재등장 가능성이 큼

- `recurrence`:
  - 반복되는 정보는 우연보다 규칙일 가능성이 높음

- `novelty`:
  - 이미 있는 슬롯인지, 새 정보인지 반영

이 점수화는 결국 "기억 오염 방지"가 목적이다.

---

## 5. Retrieval 전략을 2단계로 둔 이유

벡터 검색만 강제하면 환경 의존성이 생긴다.
(패키지/확장 로드 실패 등)

그래서 현재 구조는 항상 2단계다.

1. 벡터 검색 가능하면 vector path 사용
- 유사도 + 슬롯 점수를 결합해 랭킹

2. 불가능하면 lexical fallback
- 토큰 overlap + 슬롯 점수로 랭킹

이 설계의 장점:
- 최적 경로(vector)를 우선 사용
- 실패해도 기능이 끊기지 않는다

즉, "성능 최적화"와 "서비스 연속성"을 동시에 잡는다.

---

## 6. 단기 기억 설계: 왜 deque를 유지하나

단기 기억은 DB 조회보다 빠른 즉시성이 중요하다.
그래서 runtime에 `deque(maxlen=6)`를 둔다.

효과:
- 바로 직전 대화 톤/호칭/문맥 반영이 쉬움
- 토큰 예산을 과도하게 쓰지 않음

주의:
- deque는 프로세스 메모리 상태이므로 재시작 시 사라진다.
- 영속성은 DB(`chat_turns`)가 담당한다.

즉, deque는 캐시이고, SQLite는 저장소다.

---

## 7. 메모리 주입은 언제/어떻게 일어나는가

메모리는 생성 전에 주입하고, 생성 후 갱신한다.

1. 생성 전
- system prompt
- memory system message(검색 결과)
- short history
- current user

2. 생성 후
- user/assistant 턴을 DB에 기록
- 후보 추출
- 점수 계산
- 슬롯 승격/upsert

이 구조 덕분에
- 현재 턴은 "이전까지의 기억"으로 답하고
- 다음 턴부터 "방금 생성된 기억"이 반영된다.

---

## 8. 감정 시스템 설계: 왜 one-hot JSON인가

감정을 자유 텍스트로 두면 UI/로직 연결이 어려워진다.
그래서 감정을 기계가 쓰기 쉬운 계약으로 고정했다.

계약:
- 키: `neutral`, `sad`, `happy`, `angry`
- 값: 0/1
- 정확히 하나만 1(one-hot)

장점:
- UI 자산 선택이 단순해짐
- 상태 저장/로그 분석이 쉬워짐
- 후속 정책(음성 스타일, 모션) 확장이 쉬움

---

## 9. 감정 판정의 2중 안전장치

감정 파이프라인도 메모리와 같은 철학을 쓴다.

1. 1차: LLM 판정
- narration + dialogue를 보고 JSON one-hot 출력
- `_normalize_emotion`으로 형식/우선순위 강제

2. 2차: fallback
- LLM 출력이 깨지면 키워드 규칙으로 최소 기능 유지

즉, 정확도는 LLM에 기대고, 가용성은 fallback으로 보장한다.

---

## 10. 감정 → UI 변환은 왜 분리했는가

감정 판정 로직과 화면 렌더 로직을 직접 섞으면 유지보수가 어렵다.
현재는 변환 단계를 명확히 분리한다.

- 판정 결과: one-hot JSON
- 변환 함수: `_pick_char_b64`
- 자산 매핑:
  - neutral → `neutral_full.png`
  - sad → `crying_full.png`
  - happy → `smile_full.png`
  - angry → `annoyed_full.png`

이렇게 두면 나중에
- 감정 종류를 늘리거나
- 자산 파일명을 바꾸거나
- 렌더 엔진을 바꿔도
영향 범위를 좁게 유지할 수 있다.

---

## 11. 동시성 관점에서 기억/감정이 깨지지 않게 하는 법

웹 환경에서 가장 흔한 실패는 "동시 턴 처리로 상태가 섞이는 것"이다.

현재 구조의 방어선:

- `RuntimeServices._turn_lock`
  - turn 처리 직렬화
  - history/memory 업데이트 순서 보장

- SQLite `check_same_thread=False`
  - 스레드 제약 해제는 하되, 실제 접근은 상위 lock으로 제어

즉, 병렬 처리보다 먼저 **일관성 보장**을 선택한 구조다.

---

## 12. 이 구조를 구현할 때 중요한 설계 순서

직접 비슷한 시스템을 만들려면 아래 순서를 권장한다.

1. 데이터 모델부터 고정
- `chat_turns`, `candidates`, `slots` 역할 분리

2. short/long memory 경계 정의
- 어떤 정보가 어느 층에 들어가는지 결정

3. 승격 규칙 점수화
- "무엇을 기억할지"를 명시 규칙으로 만들기

4. retrieval 2단계 설계
- vector path + fallback path

5. 감정 계약(one-hot) 고정
- UI/오디오와 연결하기 전에 출력 규약부터 고정

6. 락/스레드 정책 확정
- 상태를 언제 어떻게 직렬화할지 먼저 결정

이 순서를 지키면, 기능 추가보다 중요한 "구조 안정성"을 먼저 확보할 수 있다.

---

## 13. 운영/튜닝 시 체크해야 할 것

1. 기억이 너무 많이 쌓일 때
- `promote_threshold` 상향
- type importance 조정
- retrieval_limit 축소

2. 기억이 너무 적게 남을 때
- `promote_threshold` 하향
- recurrence/novelty 가중치 조정

3. 벡터 검색이 비활성일 때
- 로그의 `vector_enabled`, `sqlite_vec_loaded` 확인
- numpy/sklearn/sqlite-vec 로딩 상태 점검

4. 감정이 이상할 때
- LLM JSON 원문 확인
- `_normalize_emotion` 통과 결과 확인
- fallback 키워드 규칙과 충돌 여부 점검

---

## 14. 핵심 요약

이 시스템의 핵심은 다음 세 줄로 요약된다.

- 단기 기억은 빠르게, 장기 기억은 엄격하게 관리한다.
- 장기 기억은 후보-승격-검색을 분리해 오염을 줄인다.
- 감정은 one-hot 계약으로 고정해 추론/렌더를 안정적으로 연결한다.

이 원칙을 유지하면, 모델이 바뀌어도 메모리와 감정 시스템은 안정적으로 재사용할 수 있다.
